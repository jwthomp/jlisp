[ ] atom
[ ] Fix reading from command line to not submit to reader until a complete form is ready
[ ] fix crash in (cond ((eq 1 1) (status)))
[ ] Implement macros

Add new VT_MACRO (same as function)
Create DEFMACRO that is same is DEFUN but does VT_MACRO
Create functions macro_expand(value_t *) and macro_expand_1(value_t *)

_1
if (is_cons(p) && is_macro(car(p))) return eval(p); else return p;
returns 2 values: modified p and bool (true if something was expanded, and false if not)

non_1 recursive that calls macro_expand_1 until there's nothing more to expand
keep calling _1 until it returns false

do macro_expand_1 like int macro_expand_1(value_t **p) // 0 = p unchanged, 1 = expanded and p is expanded


[X] fix crash in (gc) then (cons a b)
[X] Make binding a lisp object (cons)
[X] cond
[X] quote, eq, cons, car, cdr, cond
[X] Defparameter
[X] Add support for defun add1 (x) (+ 1 x)
[X] Modify reader to handle numbers
[X] Modify reader to handle strings
[X] Fix search for a binding in an environment
[X] Get typing a symbol in by itself working
[X] Make an environment type lisp object
[X] Implement special operators - quote, setq, lambda
[X] Write compiler
[X] Implement Closure lisp object
[X] Implement Lambda lisp object
		parameter list (list of symbols)
		body (bytecode)
		pool (literal lisp objects that the body refers to

	Compiling is
		Create a new lambda object
		Verify the parameter list and assign it
		Compile the body, which creates the pool
		Return the the lambda object

	compile(lispobj *plist, lispobj *body) {
		labmda_t m;
		for_each(p in plist) { assert(is_symbol(p));}
		m.plist = plist;
		for_each(p in body) {compile_form(&m, p); }
		return make_lambda-lisp_object(&m);
	}

... eval basically amounts to:
lispobj *lambda = compile(nil, list(body));
lispobj *closure = make_closure(lambda, current_environment);
run(closure);

compile_form(lisp_obj* p)
{
	if (islist(p)) compile_function(p)
	elseif (issymbol(p)) assembly(LOAD, p);
	else assemble(PUSH, p);
}

compile_function(lisp_obj *p)
{
	lispobj *f = car(p);
	lispobj *args = cdr(p);
	compile_form(f);
	int argc = compile_args(args);
	assemble(CALL, argc);
}

pool is array of value_t's
bytecode is an array of numbers
push 10 means push pool[10] onto stack
jump 30 means set the pc to index 30 of the bytecode
call 2 means..
loadf 20 means load the function for symbol at pool[20]



push_index(int i)
stack[sp++] = stack[(i < 0) ? sp + i ; bp + i]

let;s you do -1, etc..

void replace(int i); // i acts like push_index, but makes i the top of the stack, replacing whatever's there with the current top
	replace(int i) { i += (i<0) ? sp : bp; stack[i++] = stack[sp-1]; sp = i;

void uncons(int i); // again, i is the same as push_index
	lispobj**p = &stack[...];
	stack[sp++] = car(*p);
	*p = cdr(*p);

special operators take a different compilation path

compile_quote(lispobj * args)
{
	lisobj *x = car(args);
	assert(is_nil(cdr(args))) // syntax check
	assemble (PUSH, x);
}
