[ ] atom
[ ] Tuple support
[ ] Bit format support
[ ] Function pattern matching
[ ] receive pattern matching
[ ] Implement let* (sequential)
[ ] Fix so that value_t's can be compared against eachother
[ ] Add support for floats
[ ] Add in support for multi-generational GC
[ ] Implement for
[ ] List comprehensions
[ ] implement deconstruct-bind
[ ] Support packages
[ ] Add FFI support
[ ] How to do shared dev?

[ ] Tuples
[ ] Matching


[ ] Move top level kern_env and usr_env to their own heap and anything put there should get stuck onto that heap
[ ] Allow processes to be freed
[ ] Process spawning and death
	[ ] Create VT_PID
	[ ] Write Spawn
	[ ] Allow process to die
[ ] Make stack data and env array data values so they get cleaned up when a vm dies
[ ] Send/Receive for processes

[ ] Write unit tests for stable functionality




[ ] Implement dynamic and lexical scoped symbols as totally different namespaces



[ ] Support `,
[ ] Support ,@
[ ] Improve verify messages
[ ] Support for examining stack
[ ] Support for examining closure
[ ] Make a master VM which handles things like temporary strings, and static binds

[ ] Need to make read not block
read ->
	VM -> Call read ifunc
	C -> do we have a character
	C -> Should we return, if yes return the value read in
	C -> If not, return some kind of continue value
	VM -> If read in value, return
	VM -> If continue, jump to call (since jmp is an instruction a test should
			take place to see if another process should run


[/] fix &rest so 'a sets args to ('a)


[X] Fix bug in reader where strings were being capitalized
[X] Fix bug in lisp running repl where (let (())...) was not properly finding binding
[X] Add in a binary heap where all binary objects (strings, etc) that don't need to be
    moved but are mark/swept instead
[X] Add in support for multiple pools between garbage collections
[X] Get unit test suite in here
[X] Need to have main just launch this code for the vm
[x] Implement eval
[x] Implement read
[x] Implement (loop (print (eval (read))))
[X] Implement Loop
[X] Move special form macro's out of compile and into lib
[X] Fix (progn 'a 'b)
[X] macro's do not have their arguments expanded. Fix this
[X] Allow C lisp functions to be flagged as macros
[X] (let ((counter 1)) (defun inc () (setq counter (+ counter 1))) (defun reset () (setq counter 0)))
[X] Make lambda handle multiple args in body and only return result of last
[X] Implement progn -> convert to lambda
[X] Modify let to just result in a lambda
[X] Try (defvar x 1) (cond ((< x 0) (setq x (+ x 10))))
[X] Make sure that setq updates x
[X] Implement defvar binds value in current env
[X] Fix lambda ((lambda (x) (print x)) 10)
[X] Do argument count checking for built in special forms
[X] Fix reading from command line to not submit to reader until a complete form is ready
[X] write unwind-protect - does a setjmp that will execute a different body of code
[X] Support loading from a file
[X] Exceptions
[X] Reader macro -> '
[X] fix crash in (cond ((eq 1 1) (status)))
[X] Implement macros
[X] fix crash in (gc) then (cons a b)
[X] Make binding a lisp object (cons)
[X] cond
[X] quote, eq, cons, car, cdr, cond
[X] Defparameter
[X] Add support for defun add1 (x) (+ 1 x)
[X] Modify reader to handle numbers
[X] Modify reader to handle strings
[X] Fix search for a binding in an environment
[X] Get typing a symbol in by itself working
[X] Make an environment type lisp object
[X] Implement special operators - quote, setq, lambda
[X] Write compiler
[X] Implement Closure lisp object
[X] Implement Lambda lisp object
		parameter list (list of symbols)
		body (bytecode)
		pool (literal lisp objects that the body refers to

	Compiling is
		Create a new lambda object
		Verify the parameter list and assign it
		Compile the body, which creates the pool
		Return the the lambda object

	compile(lispobj *plist, lispobj *body) {
		labmda_t m;
		for_each(p in plist) { assert(is_symbol(p));}
		m.plist = plist;
		for_each(p in body) {compile_form(&m, p); }
		return make_lambda-lisp_object(&m);
	}

... eval basically amounts to:
lispobj *lambda = compile(nil, list(body));
lispobj *closure = make_closure(lambda, current_environment);
run(closure);

compile_form(lisp_obj* p)
{
	if (islist(p)) compile_function(p)
	elseif (issymbol(p)) assembly(LOAD, p);
	else assemble(PUSH, p);
}

compile_function(lisp_obj *p)
{
	lispobj *f = car(p);
	lispobj *args = cdr(p);
	compile_form(f);
	int argc = compile_args(args);
	assemble(CALL, argc);
}

pool is array of value_t's
bytecode is an array of numbers
push 10 means push pool[10] onto stack
jump 30 means set the pc to index 30 of the bytecode
call 2 means..
loadf 20 means load the function for symbol at pool[20]



push_index(int i)
stack[sp++] = stack[(i < 0) ? sp + i ; bp + i]

let;s you do -1, etc..

void replace(int i); // i acts like push_index, but makes i the top of the stack, replacing whatever's there with the current top
	replace(int i) { i += (i<0) ? sp : bp; stack[i++] = stack[sp-1]; sp = i;

void uncons(int i); // again, i is the same as push_index
	lispobj**p = &stack[...];
	stack[sp++] = car(*p);
	*p = cdr(*p);

special operators take a different compilation path

compile_quote(lispobj * args)
{
	lisobj *x = car(args);
	assert(is_nil(cdr(args))) // syntax check
	assemble (PUSH, x);
}
